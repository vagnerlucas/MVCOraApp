-- Table USER

CREATE TABLE TB_USER (
  ID_USER INT NOT NULL,
  LOGIN VARCHAR(50) NOT NULL,
  PASSWD VARCHAR(200) NOT NULL,
  USER_NAME VARCHAR(100) NOT NULL );

ALTER TABLE TB_USER ADD PRIMARY KEY (ID_USER);

CREATE SEQUENCE SQ_USER;

ALTER TABLE TB_USER
  ADD PASSWDSALT varchar2(200);
  
create or replace 
TRIGGER TR_USER_SEQUENCE
  BEFORE INSERT 
  ON TB_USER
  FOR EACH ROW

  WHEN (NEW.ID_USER is null)
DECLARE
  vId TB_USER.ID_USER%TYPE;
BEGIN
  SELECT SQ_USER.nextval INTO vId FROM DUAL;

  :NEW.ID_USER := vId;
END;

-- Table GROUP 

CREATE TABLE TB_GROUP (
  ID_GROUP INT NOT NULL,
  GROUP_NAME VARCHAR(50) NOT NULL,
  GROUP_DESCRIPTION VARCHAR(100) );
  
ALTER TABLE TB_GROUP ADD PRIMARY KEY (ID_GROUP);

CREATE SEQUENCE SQ_GROUP;

create or replace 
TRIGGER TR_GROUP_SEQUENCE
  BEFORE INSERT 
  ON TB_GROUP
  FOR EACH ROW
  WHEN (NEW.ID_GROUP is null)
DECLARE
  vId TB_GROUP.ID_GROUP%TYPE;
BEGIN
  SELECT SQ_GROUP.nextval INTO vId FROM DUAL;
  :NEW.ID_GROUP := vId;
END;

-- Table GROUP_USER

CREATE TABLE TB_GROUP_USER (
  ID_GROUP_USER INT NOT NULL,
  ID_USER INT NOT NULL,
  ID_GROUP INT NOT NULL,
  OBS VARCHAR(100) );
  
ALTER TABLE TB_GROUP_USER ADD PRIMARY KEY (ID_GROUP_USER);

ALTER TABLE TB_GROUP_USER ADD CONSTRAINT FK_GROUP_USER_USER FOREIGN KEY (ID_USER) REFERENCES TB_USER (ID_USER);
ALTER TABLE TB_GROUP_USER ADD CONSTRAINT FK_GROUP_USER_GROUP FOREIGN KEY (ID_GROUP) REFERENCES TB_GROUP (ID_GROUP);

CREATE SEQUENCE SQ_GROUP_USER;

create or replace 
TRIGGER TR_GROUP_USER_SEQUENCE
  BEFORE INSERT 
  ON TB_GROUP_USER
  FOR EACH ROW
  WHEN (NEW.ID_GROUP_USER is null)
DECLARE
  vId TB_GROUP_USER.ID_GROUP_USER%TYPE;
BEGIN
  SELECT SQ_GROUP_USER.nextval INTO vId FROM DUAL;
  :NEW.ID_GROUP_USER := vId;
END;

-- Table CATEGORY

CREATE TABLE TB_CATEGORY (
  ID_CATEGORY INT NOT NULL,
  DESCRIPTION VARCHAR(100) NOT NULL);
  
ALTER TABLE TB_CATEGORY ADD PRIMARY KEY (ID_CATEGORY);

CREATE SEQUENCE SQ_CATEGORY;

create or replace 
TRIGGER TR_CATEGORY_SEQUENCE
  BEFORE INSERT 
  ON TB_CATEGORY
  FOR EACH ROW

  WHEN (NEW.ID_CATEGORY is null)
DECLARE
  vId TB_CATEGORY.ID_CATEGORY%TYPE;
BEGIN

  SELECT SQ_CATEGORY.nextval INTO vId FROM DUAL;

  :NEW.ID_CATEGORY := vId;
END;

-- Table SUBCATEGORY

CREATE TABLE TB_SUBCATEGORY (
  ID_SUBCATEGORY INT NOT NULL,
  ID_CATEGORY INT NOT NULL,
  DESCRIPTION VARCHAR(100) NOT NULL);
  
ALTER TABLE TB_SUBCATEGORY ADD PRIMARY KEY (ID_SUBCATEGORY);

ALTER TABLE TB_SUBCATEGORY ADD CONSTRAINT FK_SUBCATEGORY_CATEGORY FOREIGN KEY (ID_CATEGORY) REFERENCES TB_CATEGORY (ID_CATEGORY);

CREATE SEQUENCE SQ_SUBCATEGORY;

create or replace 
TRIGGER TR_SUBCATEGORY_SEQUENCE
  BEFORE INSERT 
  ON TB_SUBCATEGORY
  FOR EACH ROW
  WHEN (NEW.ID_SUBCATEGORY is null)
DECLARE
  vId TB_SUBCATEGORY.ID_SUBCATEGORY%TYPE;
BEGIN
  SELECT SQ_SUBCATEGORY.nextval INTO vId FROM DUAL;
  :NEW.ID_SUBCATEGORY := vId;
END;

-- Table PRODUCT

CREATE TABLE TB_PRODUCT (
  ID_PRODUCT INT NOT NULL,
  ID_USER INT NOT NULL,
  ID_SUBCATEGORY INT NOT NULL,
  DESCRIPTION VARCHAR(100) NOT NULL);
  
ALTER TABLE TB_PRODUCT ADD PRIMARY KEY (ID_PRODUCT);

ALTER TABLE TB_PRODUCT ADD CONSTRAINT FK_PRODUCT_SUBCATEGORY FOREIGN KEY (ID_SUBCATEGORY) REFERENCES TB_SUBCATEGORY (ID_SUBCATEGORY);
ALTER TABLE TB_PRODUCT ADD CONSTRAINT FK_PRODUCT_USER FOREIGN KEY (ID_USER) REFERENCES TB_USER (ID_USER);

CREATE SEQUENCE SQ_PRODUCT;

create or replace 
TRIGGER TR_PRODUCT_SEQUENCE
  BEFORE INSERT 
  ON TB_PRODUCT
  FOR EACH ROW
  WHEN (NEW.ID_PRODUCT is null)
DECLARE
  vId TB_PRODUCT.ID_PRODUCT%TYPE;
BEGIN
  SELECT SQ_PRODUCT.nextval INTO vId FROM DUAL;
  :NEW.ID_PRODUCT := vId;
END;

-- Table LOG_PRODUCT

CREATE TABLE TB_PRODUCT_LOG (
  ID_PRODUCT_LOG INT NOT NULL,
  ID_USER INT NOT NULL,
  ID_PRODUCT INT NOT NULL,
  OPERATION VARCHAR(50),
  WHEN_REG DATE);
 
ALTER TABLE TB_PRODUCT_LOG ADD PRIMARY KEY (ID_PRODUCT_LOG);
 
CREATE SEQUENCE SQ_PRODUCT_LOG;

create or replace 
TRIGGER TR_PRODUCT_LOG_SEQUENCE
  BEFORE INSERT 
  ON TB_PRODUCT_LOG
  FOR EACH ROW
  WHEN (NEW.ID_PRODUCT_LOG is null)
DECLARE
  vId TB_PRODUCT_LOG.ID_PRODUCT_LOG%TYPE;
BEGIN
  SELECT SQ_PRODUCT_LOG.nextval INTO vId FROM DUAL;
  :NEW.ID_PRODUCT_LOG := vId;
END;

-- Trigger for TB_PRODUCT

CREATE TRIGGER TR_PRODUCT_LOG AFTER
  INSERT OR DELETE OR UPDATE ON TB_PRODUCT
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    INSERT INTO TB_PRODUCT_LOG(ID_PRODUCT_LOG, ID_USER, ID_PRODUCT, OPERATION, WHEN_REG)
      VALUES (SQ_PRODUCT_LOG.NEXTVAL, :NEW.ID_USER, :NEW.ID_PRODUCT, 'REG. INSERIDO ', SYSDATE);
  ELSIF DELETING THEN
    INSERT INTO TB_PRODUCT_LOG(ID_PRODUCT_LOG, ID_USER, ID_PRODUCT, OPERATION, WHEN_REG)
      VALUES (SQ_PRODUCT_LOG.NEXTVAL, :OLD.ID_USER, :OLD.ID_PRODUCT, 'REG. DELETADO ', SYSDATE);
  ELSIF UPDATING THEN
    INSERT INTO TB_PRODUCT_LOG(ID_PRODUCT_LOG, ID_USER, ID_PRODUCT, OPERATION, WHEN_REG)
      VALUES (SQ_PRODUCT_LOG.NEXTVAL, :NEW.ID_USER, :NEW.ID_PRODUCT, 'REG. ATUALIZADO ', SYSDATE);
  END IF;
END;

-- View for PRODUCT x CATEGORY x SUBCATEGORY

CREATE VIEW VW_PRODUCT_CATEGORIES AS 
SELECT P.ID_PRODUCT "ID", P.DESCRIPTION "Descrição", S.DESCRIPTION "SubCategoria", C.DESCRIPTION "Categoria" FROM 
	TB_PRODUCT P INNER JOIN TB_SUBCATEGORY S ON (S.ID_SUBCATEGORY = P.ID_SUBCATEGORY) 
		    INNER JOIN TB_CATEGORY C ON (C.ID_CATEGORY = S.ID_CATEGORY);